package fr.inserm.u1078.tludwig.vcfprocessor.functions.analysis;

import fr.inserm.u1078.tludwig.vcfprocessor.documentation.Description;
import fr.inserm.u1078.tludwig.maok.UniversalReader;
import fr.inserm.u1078.tludwig.vcfprocessor.functions.Function;
import fr.inserm.u1078.tludwig.vcfprocessor.functions.parameters.TSVFileParameter;
import fr.inserm.u1078.tludwig.vcfprocessor.testing.TestingScript;
import java.util.ArrayList;

/**
 * Outputs the Joint Site Frequency Spectrum Summary statistics
 * 
 * @author Thomas E. Ludwig (INSERM - U1078) 
 * Started on             2016-05-31
 * Checked for release on 2020-05-12
 * Unit Test defined on   2020-09-10 //TODO depends on JointFrequencySpectrum
 */
public class JFSSummary extends Function {

  private final TSVFileParameter infile = new TSVFileParameter(OPT_FILE, "GROUP1.GROUP2.XXX.YYY.ZZZ.tsv", "input tsv file");
  private int N;
  int threshold;
  private double V = 0;
  private int[][] count;
  private double[][] phi;

  public static final double THRESHOLD = 0.05; //for small samples, should be 0.01 on large samples

  @Override
  public String getSummary() {
    return "Outputs the Joint Site Frequency Spectrum Summary statistics";
  }

  @Override
  public Description getDescription() {
    return new Description(this.getSummary())
            .addLine("See https://www.nature.com/articles/ejhg2013297")
            .addLine("The input file contains the JFS data comparing to groups of samples.")
            .addLine("Those data, generated by the function " + Description.function(JointFrequencySpectrum.class) + " are in the following format : ")
            .addLine("a (2n+1)x(2n+1) matrix, where n is the number of samples in each population. The number at matrix[A][B], is the number of variants for which the first group has A variant alleles and the second group has B variant alleles")
            .addLine("The output information are")
            .addItemize(new String[]{
              "N = Number of haplotypes in each population (2xn -- the num of samples per pop.)",
              "V = Total number of variants",
              "threshold : pooled sample allele frequency (i + j)/2N &lt;= " + THRESHOLD,
              "FST = overall measure of genetic diversity",
              "AS = allele sharing statistic (probability that two individuals carrying an allele count of n come from different populations, normalized by the expected probability in panmictic population)",
              "WS = weighted symmetry (measures how evenly rare aleeles are distributed between the two populations)"
            });
  }

  @Override
  public String getOutputExtension() {
    return OUT_TXT;
  }

  @Override
  public void executeFunction() throws Exception {
    ArrayList<String> lines = new ArrayList<>();

    UniversalReader in = this.infile.getReader();
    String line;
    while ((line = in.readLine()) != null)
      lines.add(line);
    in.close();

    N = lines.size() - 1;
    threshold = (int) (2 * N * THRESHOLD);
    count = new int[N + 1][N + 1];
    phi = new double[N + 1][N + 1];

    for (int i = 0; i <= N; i++) {
      String[] f = lines.get(i).split(T);
      for (int j = 0; j <= N; j++) {
        count[i][j] = new Integer(f[j]);
        V += count[i][j];
      }
    }

    for (int i = 0; i <= N; i++)
      for (int j = 0; j <= N; j++)
        phi[i][j] = count[i][j] / V;

    double fst = getFST();
    double as = getAS();
    double ws = getWS();

    println("N = " + N);
    println("V = " + (int) V);
    println("threshold i + j <= " + threshold);
    println("FST = " + fst);
    println("AS = " + as);
    println("WS = " + ws);
  }

  private double getFST() {
    double num = 0;
    double denom = 0;
    for (int i = 0; i <= threshold; i++)
      for (int j = 0; i + j <= threshold; j++) {
        num += numFST(i, j);
        denom += denomFST(i, j);
      }
    if (denom == 0)
      return 0;
    return 1 - (num / denom);
  }

  private double numFST(int i, int j) {
    double ret = phi[i][j] * (multi(i, N) + multi(j, N));
    return ret;
  }

  private double denomFST(int i, int j) {
    double ret = phi[i][j] * 2 * multi(i + j, 2 * N);
    return ret;
  }

  private double multi(double n, int d) {
    double r = n / d;
    return r * (1 - r);
  }

  private double getAS() {
    double num = numAS();
    double denom = denomAS();
    if (denom == 0)
      return 0;
    return num / denom;
  }

  private double denomAS() {
    double sum = 0;
    for (int i = 0; i <= threshold; i++)
      for (int j = 0; i + j <= threshold; j++)
        sum += phi[i][j];
    return sum;
  }

  private double numAS() {
    double sum = 0;
    for (int n = 0; n <= threshold; n++)
      sum += getAS(n) * numSumAS(n);
    return sum;
  }

  private double numSumAS(int n) {
    double sum = 0;
    for (int i = 0; i <= n; i++)
      sum += phi[i][n - i];
    return sum;
  }

  private double getAS(int n) {
    if (n < 2)
      return 0;
    double num = 0;
    double denom = 0;
    int cn2 = (n * (n - 1)) / 2;
    for (int i = 0; i <= n; i++) {
      int j = n - i;
      num += i * j * phi[i][j];
      denom += phi[i][j];
    }
    if (denom == 0)
      return 0;
    return (2 * num) / (cn2 * denom);
  }

  private double getWS() {
    double iws = 0;
    double jws = 0;
    double denomws = 0;

    for (int i = 0; i <= threshold; i++)
      for (int j = 0; i + j <= threshold; j++) {
        iws += iWS(i, j);
        jws += jWS(i, j);
        denomws += denomWS(i, j);
      }

    if (denomws == 0)
      return 0;

    return 2 * Math.min(iws, jws) / denomws;
  }

  private double iWS(int i, int j) {
    double ret = i * phi[i][j];
    return ret;
  }

  private double jWS(int i, int j) {
    double ret = j * phi[i][j];
    return ret;
  }

  private double denomWS(int i, int j) {
    double ret = (i + j) * phi[i][j];
    return ret;
  }
  
  @Override
  public TestingScript[] getScripts() {
    TestingScript ts = TestingScript.newFileAnalysis();
    ts.addAnonymousFilename("file", "input.tsv");
    return new TestingScript[]{ts};
  }
}
